import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class Timing
{
    private static long fileStart = 0L;
    private static long fileEnd = 0L;
    private static long initStart = 0L;
    private static long initEnd = 0L;
    private static long groupInitStart = 0L;
    private static long groupInitEnd = 0L;
    private static long overlapStart = 0L;
    private static long overlapEnd = 0L;
    private static long solvingStart = 0L;
    private static long solvingEnd = 0L;
    private static long totalStart = 0L;
    private static long totalEnd = 0L;
    private static long generationStart = 0L;
    private static long generationEnd = 0L;
    private static long filteringStart = 0L;
    private static long filteringEnd = 0L;
    private static long edgeStart = 0L;
    private static long edgeEnd = 0L;
    private static long commonStart = 0L;
    private static long commonEnd = 0L;
    private static int totalPermutations = 0;
    private static int totalIterations = 0;
    private static int totalAttemptedPermutations = 0;
    private static int totalEarlyPruningInstances = 0;
    private static int totalMaxPermutations = 0;
    private static int totalAllocatedPermutations = 0;

    public enum Timings {FileReading, Initialization, CountGeneration, Overlap, SolvingLoop,
        Total, Generation, Filtering, EdgePattern, ConsistentPattern}

    /**
     * Method for setting the starting time of a solving process. Both generating and
     * filtering are a sum of all starting times.
     *
     * @param timing The name of the solving process.
     */
    public static void timingStart(Timings timing)
    {
        switch (timing)
        {
            case Timings.FileReading:
                fileStart = System.nanoTime();
                break;
            case Timings.Initialization:
                initStart += System.nanoTime();
                break;
            case Timings.CountGeneration:
                groupInitStart += System.nanoTime();
                break;
            case Timings.Overlap:
                overlapStart = System.nanoTime();
                break;
            case Timings.SolvingLoop:
                solvingStart = System.nanoTime();
                break;
            case Timings.Total:
                totalStart = System.nanoTime();
                break;
            case Timings.Generation:
                generationStart += System.nanoTime();
                break;
            case Timings.Filtering:
                filteringStart += System.nanoTime();
                break;
            case Timings.EdgePattern:
                edgeStart += System.nanoTime();
                break;
            case Timings.ConsistentPattern:
                commonStart += System.nanoTime();
                break;
            default:
                break;
        }

    }

    /**
     * Method for setting the ending time of a solving process. Both generating and
     * filtering are a sum of all ending times.
     *
     * @param timing The name of the solving process.
     */
    public static void timingEnd(Timings timing)
    {
        switch (timing)
        {
            case Timings.FileReading:
                fileEnd = System.nanoTime();
                break;
            case Timings.Initialization:
                initEnd += System.nanoTime();
                break;
            case Timings.CountGeneration:
                groupInitEnd += System.nanoTime();
                break;
            case Timings.Overlap:
                overlapEnd = System.nanoTime();
                break;
            case Timings.SolvingLoop:
                solvingEnd = System.nanoTime();
                break;
            case Timings.Total:
                totalEnd = System.nanoTime();
                break;
            case Timings.Generation:
                generationEnd += System.nanoTime();
                break;
            case Timings.Filtering:
                filteringEnd += System.nanoTime();
                break;
            case Timings.EdgePattern:
                edgeEnd += System.nanoTime();
                break;
            case Timings.ConsistentPattern:
                commonEnd += System.nanoTime();
                break;
            default:
                break;
        }

    }

    /**
     * A method for adding count of permutations generated by a group
     * to the total permutations generated.
     *
     * @param newPermutations The number of permutations generated by a group.
     */
    public static void addPermutationCount(int newPermutations)
    {
        totalPermutations += newPermutations;
    }

    public static void addMaxPermutationCount(int maxPermutations)
    {
        totalMaxPermutations += maxPermutations;
    }

    public static void addAllocatedPermutationCount(int allocatedPermutations)
    {
        totalAllocatedPermutations += allocatedPermutations;
    }

    /**
     * A method for incrementing the iteration count each update sequence.
     */
    public static void addIteration()
    {
        totalIterations++;
    }

    public static void addAttemptedPermutationCount()
    {
        totalAttemptedPermutations++;
    }

    public static void addEarlyPrunedPermutationCount()
    {
        totalEarlyPruningInstances++;
    }

    /**
     * A method for saving all the timing points to a file.
     */
    public static void saveTimings()
    {
        try (PrintWriter pw = new PrintWriter(new FileWriter("Timing.txt")))
        {
            pw.printf("Total Time: %s%n", formatTime(totalEnd - totalStart));
            pw.printf("%nFile Reading: %s%n", formatTime(fileEnd - fileStart));
            pw.printf("Initialization: %s%n", formatTime(initEnd - initStart));
            pw.printf("Total Counting Generation: %s%n", formatTime(groupInitEnd - groupInitStart));
            pw.printf("Overlap: %s%n", formatTime(overlapEnd - overlapStart));
            pw.printf("Solving Loop: %s%n", formatTime(solvingEnd - solvingStart));
            pw.printf("%nTotal Generation: %s%n", formatTime(generationEnd - generationStart));
            pw.printf("Total Filtering: %s%n", formatTime(filteringEnd - filteringStart));
            pw.printf("Total Deducing Edge Patterns: %s%n", formatTime(edgeEnd - edgeStart));
            pw.printf("Total Generating Consistent Patterns: %s%n", formatTime(commonEnd - commonStart));
            pw.printf("%nTotal Permutations Generated: %,d%n", totalPermutations);
            pw.printf("Total Allocated Permutations: %,d%n", totalAllocatedPermutations);
            pw.printf("Total Attempted Partial Permutations: %,d%n", totalAttemptedPermutations);
            pw.printf("Total Early Pruning Instances: %,d%n", totalEarlyPruningInstances);
            pw.printf("Total Maximum Permutations: %,d%n", totalMaxPermutations);
            pw.printf("%nTotal Iterations: %,d%n", totalIterations);

        } catch (IOException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * A method for formatting times into an appropriate format.
     *
     * @param nanos Time in nanoseconds
     * @return Time formated to microseconds, milliseconds or seconds.
     */
    private static String formatTime(long nanos)
    {
        if (nanos < 1_000_000)
            return nanos / 1_000 + " Âµs";
        else if (nanos < 1_000_000_000)
            return nanos / 1_000_000 + " ms";
        else
            return nanos / 1_000_000_000.0 + " s";
    }
}